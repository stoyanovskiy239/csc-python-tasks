Напишите класс SortedDict, устроенный внутри как двоичное дерево поиска.
Он должен поддерживать все те операции, которые предполагает collections.abc.MutableMapping.
В частности, он должен мгновенно возвращать количество элементов (не занимайтесь подсчётом через обход дерева).

Сделайте его сбалансированным. Или, как минимум, обеспечьте, чтобы высота дерева логарифмически зависела от количества элементов (у по-настоящему сбалансированных АВЛ-деревьев основание логарифма одно, у КЧ-деревьев другое, а у идеально уравновешенных деревьев - третье, стремящееся к 2).
Начните с того, что сделайте хотя бы наивное дерево. Стресс-тестов на дисбаланс нет. Но для зачёта нужна балансировка.

Если придумаете, как экономить память, разделяя поддеревья между копиями ваших словарей - так, что изменения одного не затрагивают другого (а для деревьев это возможно!), - это будет большим плюсом.
Но в худшем случае, конечно, копии делаются через deepcopy.

Также большим плюсом будет поддержать дополнительные параметры, как у функции sorted - то есть, key и reverse.
(В тестах этого нет, чтобы можно было сосредоточиться на логике работы с деревом).

SortedDict обязательно должен принимать в качестве аргумента конструктора
SortedDict
dict и вообще любых представителей collections.abc.Mapping - извлекая оттуда пары ключ: значение
любые итерируемые наборы пар (ключ, значение)
конструктор без аргументов создаёт пустой словарь