Напишите декоратор @smart_args, который умеет делать следующее. Он анализирует типы значений по умолчанию аргументов функции и, в зависимости от этого, копирует и/или вычисляет их перед выполнением функции:

Evaluated(func_without_args) - подставляет значение по умолчанию, вычисляемое в момент вызова
Isolated() - это фиктивное значение по умолчанию; аргумент должен быть передан, но в момент передачи - скопирован.
Также напишите определения Evaluated и Isolated.

(Примечание. Можно было бы сюда ещё и Frozen(default_value) добавить, - но в этом нет смысла, т.к. для разметки одного конкретного значения это то же самое, что написать copy.deepcopy(default_value), - а для всех значений у нас уже есть @freeze_defaults)

Поскольку мы не затрагивали тему интроспекции и дизассемблирования, то ограничимся следующими рамками:

все эти волшебные аргументы - исключительно именованные, а не позиционные
не нужно сочетать Isolated и Evaluated
добавьте проверки (assert) того, что пользователь случайно не вышел за эти рамки.
